# Backtracking

- [**Concepts**](#concepts)
- [**Algorithm**](#algorithm)
- [**Complexity**](#complexity)
- [**Problems can use this pattern**](#problems-can-use-this-pattern)
- [**Strategies**](#strategies)
- [**References**](#references)

## Concepts
- Backtracking is to find all or some feasible solutions for constraint satisfaction problems (A set of objects whose state must satisfy a number of constraints or limitations).

## Algorithm
- Basic idea
   - Incrementally builds candidates to the solutions, and abandons a candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
- Search tree
   - Structure
      - The root node is a empty candidate with 0 elements.
      - Each node is a candidates with partial elements 
      - Each child node is generated by adding a new element from the parent node (Going from parent to child is a single extension step).
   - Example
      - E<sub>i</sub>: The ith element.
      - C<sub>i</sub>: The ith choice.
   
     ![Backtracking](https://user-images.githubusercontent.com/8989447/117559094-a6a21380-b03f-11eb-9cd0-7e7c90a45b90.png)
   - Process
      - Traverse the search tree by depth-first search.
      - For each node:
         - If the current node is not a valid solution, the sub-tree from the current node can be ignored.
         - If the current node is a valid solution
            - Recurse on all the child nodes from the current node.
- Code
  ```
  void backtracking(Element ele, List<Element> candidate, Object otherParams) {
      if (ele is the last element) {
          // wrap up the valid solutions we have
      } 
      
      if (ele is valid) {
          candidate.add(ele)
          backtracking(ele.choice1, candidate, otherParams)
          backtracking(ele.choice2, candidate, otherParams)
          candidate.remove(ele)
      }
  }
  ```

## Complexity
- Time complexity
   - The number of choices is C, so the time complexity is O(C<sup>n</sup>)
- Space complexity
   - O(n)

## Problems can use this pattern
- Enumeration (Find all possible solutions)
   - [Generate All Combinations of Parentheses](../../docs/problems/string/parentheses/Generate_All_Combinations_Of_Parentheses.md)
   - [Get All Possible Strings by Removing Minimum Number of Invalid Parentheses](../../docs/problems/string/parentheses/Get_All_Possible_Strings_By_Removing_Minimum_Number_Of_Invalid_Parentheses.md)
   - [Get All Word Combinations for Constructing String](docs/problems/string/Get_All_Word_Combinations_For_Constructing_String.md)
   - [Get All Operator Combinations to Make Expression Match Target Number](../../docs/problems/string/Get_All_Operator_Combinations_To_Make_Expression_Match_Target_Number.md)

## Strategies
- For the problems of finding all possible solutions, consider other solution patterns first, if not possible, use backtracking.
   - Reason: The time complexity of backtracking is the worst.
- When using backtracking, identify:
   - 3 key points
      - What is the element?
      - What are the choices for each element?
      - What are constraints?
   - Example
     | Problem | Element | Choices |
     |---|---|---|
     | Get All Possible Strings by Removing Minimum Number of Invalid Parentheses | Each character | <ul><li>Keep the current character<li>Remove the current character</ul> |
     | Generate All Combinations of Parentheses | Each character | <ul><li>Add `(`<li>Add `)`</ul> |
     | Get All Operator Combinations to Make Expression Match Target Number | Each gap between each 2 digits | <ul><li>No operator<li>`+` operator<li>`-` operator<li>`x` operator</ul>

## References
- https://en.wikipedia.org/wiki/Backtracking
- https://www.geeksforgeeks.org/backtracking-introduction/#:~:text=Backtracking%20can%20be%20defined%20as,search%20for%20a%20feasible%20solution.
